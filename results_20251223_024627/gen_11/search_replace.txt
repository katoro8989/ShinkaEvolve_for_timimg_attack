<NAME>
ctcompare_precomputed_codes
</NAME>

<DESCRIPTION>
Introduce a constant-time style comparison by precomputing Unicode code points for both strings, padding the shorter one with zeros to a fixed maximum length, and then performing a single, branch-free pass. This removes the early exit (length mismatch) and eliminates per-iteration ord() calls, reducing timing variance due to character-by-character checks and improving overall performance while preserving correctness.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def secure_compare(secret: str, input_val: str) -> bool:
    """
    2つの文字列が一致するか判定する関数。
    現在は典型的な「タイミング脆弱性」を含んでいる。
    1文字でも違うと即座に False を返すため、
    先頭で間違える場合と末尾で間違える場合で実行時間が異なる。
    """
    if len(secret) != len(input_val):
        return False

    n = len(secret)
    result = 0
    for i in range(n):
        result |= ord(secret[i]) ^ ord(input_val[i])
    return result == 0
# EVOLVE-BLOCK-END
=======
def secure_compare(secret: str, input_val: str) -> bool:
    """
    Constant-time comparison of two strings.
    This version avoids early returns and operates in a no-branch style
    by padding the shorter string with zeros and comparing code points
    in fixed-length blocks.
    """
    # Convert to lists of code points (integers) for both strings
    len_s = len(secret)
    len_i = len(input_val)
    max_len = len_s if len_s > len_i else len_i

    s_codes = [ord(ch) for ch in secret]
    i_codes = [ord(ch) for ch in input_val]

    # Pad to the same length to avoid branching in the loop
    s_codes.extend([0] * (max_len - len_s))
    i_codes.extend([0] * (max_len - len_i))

    diff = 0
    for a, b in zip(s_codes, i_codes):
        diff |= a ^ b
    return diff == 0
>>>>>>> REPLACE
</DIFF>