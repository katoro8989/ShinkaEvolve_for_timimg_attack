--- a/original.py
+++ b/original.py
@@ -1,20 +1,40 @@
 # EVOLVE-BLOCK-START
 def secure_compare(secret: str, input_val: str) -> bool:
     """
-    2つの文字列が一致するか判定する関数。
-    現在は典型的な「タイミング脆弱性」を含んでいる。
-    1文字でも違うと即座に False を返すため、
-    先頭で間違える場合と末尾で間違える場合で実行時間が異なる。
+    Constant-time string comparison without early exits.
+    64-bit-block processing on UTF-8 bytes to reduce Python overhead.
+    - Encode to UTF-8 bytes
+    - Pad to 64-bit (8-byte) boundary
+    - Aggregate bit-differences with XOR across 64-bit blocks
+    - Include length difference in initial diff to resist length-based timing leaks
+    - Returns True iff secret and input_val are exactly the same
     """
-    if len(secret) != len(input_val):
-        return False
+    # Convert to a uniform byte representation
+    s_bytes = secret.encode('utf-8')
+    t_bytes = input_val.encode('utf-8')
 
-    # Initialize the result to the length difference, will ensure padding for unequal lengths
-    result = len(secret) ^ len(input_val)
-    for i in range(len(secret)):
-        # Compare characters using XOR, constant time for each character
-        result |= (ord(secret[i]) ^ ord(input_val[i]))
-    # All characters match if result is 0
+    la = len(s_bytes)
+    lb = len(t_bytes)
+    max_len = la if la > lb else lb
 
-    return result == 0  # Result is 0 only if all characters matched
+    # Include length difference as part of the running diff
+    diff = la ^ lb
+
+    # Pad to a multiple of 8 bytes for 64-bit block processing
+    padded = ((max_len + 7) // 8) * 8
+    s_pad = s_bytes + b'\x00' * (padded - la)
+    t_pad = t_bytes + b'\x00' * (padded - lb)
+
+    mv_s = memoryview(s_pad)
+    mv_t = memoryview(t_pad)
+
+    # Interpret as 64-bit unsigned integers
+    w_s = mv_s.cast('Q')
+    w_t = mv_t.cast('Q')
+    blocks = padded // 8
+
+    for idx in range(blocks):
+        diff |= (w_s[idx] ^ w_t[idx])
+
+    return diff == 0
 # EVOLVE-BLOCK-END