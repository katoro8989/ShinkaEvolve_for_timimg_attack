<NAME>
block8_bytelike_ctime
</NAME>

<DESCRIPTION>
Introduce a block-wise constant-time comparison operating on UTF-8 encoded bytes to reduce Python-level per-character overhead and improve timing uniformity. The method encodes both strings to UTF-8, pads them to equal length without data-dependent branching, and processes fixed-size blocks (16 bytes) with a single XOR accumulator. This reduces overhead from per-character operations and makes the timing less sensitive to where mismatches occur, while preserving the correct True/False semantics for exact equality. It avoids using built-in constant-time helpers and keeps everything self-contained.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def secure_compare(secret: str, input_val: str) -> bool:
    """
    Constant-time comparison between two strings.
    Returns True if secret and input_val are exactly equal, otherwise False.
    The implementation avoids early returns and inspects all characters (padding
    shorter string with zeros) to ensure uniform timing characteristics.
    """
    len_s = len(secret)
    len_i = len(input_val)

    # Start with a difference indicator that also captures length differences
    diff = len_s ^ len_i

    # Compare up to the maximum length of the two strings
    n = max(len_s, len_i)
    for idx in range(n):
        # Fetch character code points if within bounds; otherwise use 0 as padding
        a = ord(secret[idx]) if idx < len_s else 0
        b = ord(input_val[idx]) if idx < len_i else 0
        diff |= a ^ b  # accumulate any difference in a way that does not short-circuit

    return diff == 0
# EVOLVE-BLOCK-END
=======
def secure_compare(secret: str, input_val: str) -> bool:
    """
    Constant-time comparison between two strings using fixed-block XOR over UTF-8 bytes.
    Returns True if secret and input_val are exactly equal, otherwise False.
    This approach encodes to bytes, pads to equal length without branching, and
    processes in fixed-size blocks to avoid data-dependent timing.
    """
    b1 = secret.encode('utf-8')
    b2 = input_val.encode('utf-8')

    len1 = len(b1)
    len2 = len(b2)
    max_len = len1 if len1 >= len2 else len2

    # Early return for completely empty case
    if max_len == 0:
        return True

    # Pad with zeros to equal length (no branching inside the main loop)
    if max_len > len1:
        b1 = b1 + b'\x00' * (max_len - len1)
    if max_len > len2:
        b2 = b2 + b'\x00' * (max_len - len2)

    diff = len1 ^ len2

    BLOCK = 16
    for i in range(0, max_len, BLOCK):
        chunk1 = b1[i:i+BLOCK]
        chunk2 = b2[i:i+BLOCK]
        diff |= int.from_bytes(chunk1, 'little') ^ int.from_bytes(chunk2, 'little')

    return diff == 0
# EVOLVE-BLOCK-END
>>>>>>> REPLACE
</DIFF>