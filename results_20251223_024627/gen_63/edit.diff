--- a/original.py
+++ b/original.py
@@ -1,14 +1,21 @@
 # EVOLVE-BLOCK-START
 def secure_compare(secret: str, input_val: str) -> bool:
     """
-    Constant-time style comparison using utf-32-le encoding and large-integer XOR.
-    The two strings are encoded to 32-bit code units and compared as a single
-    large integer, avoiding per-character branching and early exits.
-    Returns True only if both strings are exactly equal (same length and content).
+    Cross-over: constant-time comparison using utf-32-le encoding and non-branching blockwise XOR.
+    - Processes 4-byte code units (32-bit) across the maximum length of both strings.
+    - Missing units are padded with zeros to account for length differences.
+    - No early exits or data-dependent branching; returns True only if strings are exactly equal.
     """
-    # Encode as UTF-32 little-endian so each character is a fixed 4-byte unit
     a = secret.encode('utf-32-le')
     b = input_val.encode('utf-32-le')
-    # Compare by XOR-ing the full integer representations
-    return (int.from_bytes(a, 'little') ^ int.from_bytes(b, 'little')) == 0
+    max_len = max(len(secret), len(input_val))
+
+    diff = 0
+    for i in range(max_len):
+        base = 4 * i
+        va = int.from_bytes(a[base:base+4].ljust(4, b'\x00'), 'little')
+        vb = int.from_bytes(b[base:base+4].ljust(4, b'\x00'), 'little')
+        diff |= (va ^ vb)
+
+    return diff == 0
 # EVOLVE-BLOCK-END