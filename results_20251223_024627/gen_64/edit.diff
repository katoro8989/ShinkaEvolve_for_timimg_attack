--- a/original.py
+++ b/original.py
@@ -1,24 +1,27 @@
 # EVOLVE-BLOCK-START
 def secure_compare(secret: str, input_val: str) -> bool:
     """
     Constant-time comparison between two strings.
     Returns True if secret and input_val are exactly equal, otherwise False.
     The implementation avoids early returns and inspects all characters (padding
     shorter string with zeros) to ensure uniform timing characteristics.
     """
-    len_s = len(secret)
-    len_i = len(input_val)
+    # Convert strings to byte arrays
+    b1 = secret.encode('utf-8')
+    b2 = input_val.encode('utf-8')
 
-    # Start with a difference indicator that also captures length differences
-    diff = len_s ^ len_i
+    len1 = len(b1)
+    len2 = len(b2)
+    max_len = max(len1, len2)
 
-    # Compare up to the maximum length of the two strings
-    n = max(len_s, len_i)
-    for idx in range(n):
-        # Fetch character code points if within bounds; otherwise use 0 as padding
-        a = ord(secret[idx]) if idx < len_s else 0
-        b = ord(input_val[idx]) if idx < len_i else 0
-        diff |= a ^ b  # accumulate any difference in a way that does not short-circuit
+    # Initialize diff with length difference
+    diff = len1 ^ len2
 
-    return diff == 0
+    # Pad both byte arrays to the same length and compare
+    for i in range(max_len):
+        byte1 = b1[i] if i < len1 else 0
+        byte2 = b2[i] if i < len2 else 0
+        diff |= byte1 ^ byte2  # Accumulate differences
+
+    return diff == 0  # Return True only if all bytes matched
 # EVOLVE-BLOCK-END