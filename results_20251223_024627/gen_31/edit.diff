--- a/original.py
+++ b/original.py
@@ -1,19 +1,34 @@
 # EVOLVE-BLOCK-START
 def secure_compare(secret: str, input_val: str) -> bool:
     """
-    2つの文字列が一致するか判定する関数。
-    タイミング攻撃に耐性を持つよう、全長を走査して比較を行う。
+    Constant-time comparison of two strings with robust handling of UTF-8 bytes.
+    - Encode as UTF-8 bytes
+    - Initialize diff with XOR of lengths to reflect length differences
+    - Pad both to the same length with zero bytes (no branching)
+    - Compare in fixed-size 16-byte blocks, accumulating diff via XOR
+    - No early return; final result is diff == 0
+    Returns True iff secret == input_val
     """
-    len_s = len(secret)
-    len_i = len(input_val)
-    max_len = len_s if len_s >= len_i else len_i
-    if max_len == 0:
-        return True
-    s_pad = secret + '\0' * (max_len - len_s)
-    t_pad = input_val + '\0' * (max_len - len_i)
-    diff = 0
-    ord_ = ord
-    for idx in range(max_len):
-        diff |= ord_(s_pad[idx]) ^ ord_(t_pad[idx])
+    b1 = secret.encode('utf-8')
+    b2 = input_val.encode('utf-8')
+
+    len1 = len(b1)
+    len2 = len(b2)
+    max_len = len1 if len1 >= len2 else len2
+
+    # Pad to the same length (no branching)
+    b1 += b'\x00' * (max_len - len1)
+    b2 += b'\x00' * (max_len - len2)
+
+    # Initialize diff with length information to prevent length-based leaks
+    diff = len1 ^ len2
+
+    BLOCK = 16
+    # Process in fixed-size blocks to reduce Python overhead
+    for i in range(0, max_len, BLOCK):
+        blk1 = b1[i:i+BLOCK]
+        blk2 = b2[i:i+BLOCK]
+        diff |= int.from_bytes(blk1, 'little') ^ int.from_bytes(blk2, 'little')
+
     return diff == 0
 # EVOLVE-BLOCK-END