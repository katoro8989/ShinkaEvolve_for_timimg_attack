--- a/original.py
+++ b/original.py
@@ -1,40 +1,53 @@
 # EVOLVE-BLOCK-START
 def secure_compare(secret: str, input_val: str) -> bool:
     """
     Constant-time string comparison without early exits.
     64-bit-block processing on UTF-8 bytes to reduce Python overhead.
     - Encode to UTF-8 bytes
     - Pad to 64-bit (8-byte) boundary
     - Aggregate bit-differences with XOR across 64-bit blocks
     - Include length difference in initial diff to resist length-based timing leaks
     - Returns True iff secret and input_val are exactly the same
     """
     # Convert to a uniform byte representation
     s_bytes = secret.encode('utf-8')
     t_bytes = input_val.encode('utf-8')
 
     la = len(s_bytes)
     lb = len(t_bytes)
     max_len = la if la > lb else lb
 
     # Include length difference as part of the running diff
     diff = la ^ lb
 
     # Pad to a multiple of 8 bytes for 64-bit block processing
     padded = ((max_len + 7) // 8) * 8
     s_pad = s_bytes + b'\x00' * (padded - la)
     t_pad = t_bytes + b'\x00' * (padded - lb)
 
     mv_s = memoryview(s_pad)
     mv_t = memoryview(t_pad)
 
     # Interpret as 64-bit unsigned integers
     w_s = mv_s.cast('Q')
     w_t = mv_t.cast('Q')
     blocks = padded // 8
 
-    for idx in range(blocks):
+    idx = 0
+    limit = blocks - (blocks % 4)
+
+    # Unrolled loop: processing 4 blocks (32 bytes) per iteration
+    while idx < limit:
         diff |= (w_s[idx] ^ w_t[idx])
+        diff |= (w_s[idx + 1] ^ w_t[idx + 1])
+        diff |= (w_s[idx + 2] ^ w_t[idx + 2])
+        diff |= (w_s[idx + 3] ^ w_t[idx + 3])
+        idx += 4
+
+    # Process remaining blocks if any
+    while idx < blocks:
+        diff |= (w_s[idx] ^ w_t[idx])
+        idx += 1
 
     return diff == 0
 # EVOLVE-BLOCK-END