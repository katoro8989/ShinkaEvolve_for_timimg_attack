<NAME>
constant_time_compare
</NAME>

<DESCRIPTION>
The proposed change refactors the `secure_compare` function to ensure that it runs in constant time regardless of input differences. This is achieved by removing the early return and incorporating a consistent processing loop that handles both strings up to the maximum length. The XOR operation is maintained, but the logic ensures that all characters are processed uniformly, preventing timing attacks based on where mismatches occur. This implementation will help to improve the score by eliminating timing leaks.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def secure_compare(secret: str, input_val: str) -> bool:
    """
    2つの文字列が一致するか判定する関数。
    現在は典型的な「タイミング脆弱性」を含んでいる。
    1文字でも違うと即座に False を返すため、
    先頭で間違える場合と末尾で間違える場合で実行時間が異なる。
    """
    if len(secret) != len(input_val):
        return False

    result = 0
    for i in range(len(secret)):
        result |= (ord(secret[i]) ^ ord(input_val[i]))

    return result == 0
=======
def secure_compare(secret: str, input_val: str) -> bool:
    """
    Constant-time comparison of two strings.
    This version avoids early returns and operates in a no-branch style
    by processing characters in a non-branching manner, ensuring consistent
    timing regardless of mismatches.
    """
    len_s = len(secret)
    len_i = len(input_val)
    max_len = max(len_s, len_i)

    result = len_s ^ len_i  # Start with length difference

    for i in range(max_len):
        a = ord(secret[i]) if i < len_s else 0
        b = ord(input_val[i]) if i < len_i else 0
        result |= (a ^ b)

    return result == 0
>>>>>>> REPLACE
</DIFF>