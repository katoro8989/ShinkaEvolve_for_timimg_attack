--- a/original.py
+++ b/original.py
@@ -1,25 +1,31 @@
 # EVOLVE-BLOCK-START
 def secure_compare(secret: str, input_val: str) -> bool:
     """
-    Constant-time comparison of two strings.
-    This version processes characters in a non-branching manner,
-    ensuring consistent timing regardless of mismatches.
-    It incorporates length differences and uses a single accumulator
-    to track differences.
+    Cross-over: combines non-branching diff accumulator with utf-32-le block processing.
+    - Encodes to utf-32-le and processes 4-byte chunks.
+    - Pads shorter input with zeros to avoid data-dependent branches.
+    - Returns True only if strings are exactly equal (same length and content).
     """
-    len_s = len(secret)
-    len_i = len(input_val)
-    max_len = max(len_s, len_i)
+    a = secret.encode('utf-32-le')
+    b = input_val.encode('utf-32-le')
+    max_units = max(len(secret), len(input_val))  # number of 4-byte units
+    diff = len(secret) ^ len(input_val)  # incorporate length difference
 
-    # Initialize the accumulator to track differences.
-    diff = len_s ^ len_i  # Start with length difference
+    for i in range(max_units):
+        base = i * 4
+        # 4-byte chunk from a
+        ca = a[base:base+4]
+        if len(ca) < 4:
+            ca = ca + b'\x00' * (4 - len(ca))
+        va = int.from_bytes(ca, 'little')
 
-    # Compute differences in a constant-time manner
-    for i in range(max_len):
-        # Use 0 for out-of-range characters
-        a = ord(secret[i]) if i < len_s else 0
-        b = ord(input_val[i]) if i < len_i else 0
-        diff |= a ^ b
+        # 4-byte chunk from b
+        cb = b[base:base+4]
+        if len(cb) < 4:
+            cb = cb + b'\x00' * (4 - len(cb))
+        vb = int.from_bytes(cb, 'little')
+
+        diff |= (va ^ vb)
 
     return diff == 0
 # EVOLVE-BLOCK-END