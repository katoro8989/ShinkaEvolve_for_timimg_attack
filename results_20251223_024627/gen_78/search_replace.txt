<NAME>
constant_time_secure_compare
</NAME>

<DESCRIPTION>
The current function checks if the lengths of the two strings are equal before proceeding with character-by-character comparison, which can lead to a timing vulnerability. This change incorporates the length comparison into the main loop to ensure the function runs in constant time regardless of the input string lengths. This change will also use a single accumulator for character differences, minimizing potential leaks during string comparison. The proposed method guarantees that timing does not vary by the location of mismatches or by the overall length of the strings.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    if len(secret) != len(input_val):
        return False

    result = 0
    for i in range(len(secret)):
        result |= (ord(secret[i]) ^ ord(input_val[i]))

    return result == 0
=======
    len_s = len(secret)
    len_i = len(input_val)
    max_len = max(len_s, len_i)

    result = len_s ^ len_i  # Start with length difference

    for i in range(max_len):
        a = ord(secret[i]) if i < len_s else 0
        b = ord(input_val[i]) if i < len_i else 0
        result |= (a ^ b)

    return result == 0
>>>>>>> REPLACE
</DIFF>