<NAME>
utf32_bigint_compare
</NAME>

<DESCRIPTION>
Switch to a vectorized, constant-time-style approach by encoding both strings to UTF-32 little-endian (one codepoint per 4 bytes) and comparing their entire 32-bit codepoint sequences as a single big integer. This eliminates per-character branching and reduces Python interpreter overhead by performing a single big-integer XOR rather than a Python loop over each character. It preserves correctness (equal codepoints and lengths yield True) and avoids any early exits. While Python's timing cannot be perfectly proven constant, this approach minimizes data-dependent branches and avoids early termination paths that leak timing based on mismatch location.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def secure_compare(secret: str, input_val: str) -> bool:
    """
    Constant-time comparison of two strings.
    This version avoids early returns and operates in a no-branch style
    by processing characters in a non-branching manner, using bitwise
    operations to prevent timing leaks. The length difference is encoded
    as part of the comparison logic to ensure consistent timing regardless
    of mismatches.
    """
    len_s = len(secret)
    len_i = len(input_val)
    max_len = max(len_s, len_i)

    # Initialize the accumulator to track differences.
    diff = len_s ^ len_i  # Start with length difference

    # Compute differences in a constant-time manner
    for idx in range(max_len):
        # Use '\0' for out-of-range characters
        a = ord(secret[idx]) if idx < len_s else 0
        b = ord(input_val[idx]) if idx < len_i else 0
        diff |= a ^ b

    return diff == 0
# EVOLVE-BLOCK-END
=======
def secure_compare(secret: str, input_val: str) -> bool:
    """
    Constant-time style comparison using utf-32-le encoding and large-integer XOR.
    The two strings are encoded to 32-bit code units and compared as a single
    large integer, avoiding per-character branching and early exits.
    Returns True only if both strings are exactly equal (same length and content).
    """
    # Encode as UTF-32 little-endian so each character is a fixed 4-byte unit
    a = secret.encode('utf-32-le')
    b = input_val.encode('utf-32-le')
    # Compare by XOR-ing the full integer representations
    return (int.from_bytes(a, 'little') ^ int.from_bytes(b, 'little')) == 0
>>>>>>> REPLACE
</DIFF>